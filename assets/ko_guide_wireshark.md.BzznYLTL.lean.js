import{_ as a,a as t,b as i,c as o}from"./chunks/mavlink_message_details.DTQ5hrcX.js";import{_ as s,c as n,a8 as r,o as l}from"./chunks/framework.sDsl5pD6.js";const b=JSON.parse('{"title":"Parsing MAVLink in Wireshark","description":"","frontmatter":{},"headers":[],"relativePath":"ko/guide/wireshark.md","filePath":"ko/guide/wireshark.md"}'),p={name:"ko/guide/wireshark.md"};function c(h,e,d,u,m,g){return l(),n("div",null,e[0]||(e[0]=[r(`<h1 id="parsing-mavlink-in-wireshark" tabindex="-1">Parsing MAVLink in Wireshark <a class="header-anchor" href="#parsing-mavlink-in-wireshark" aria-label="Permalink to &quot;Parsing MAVLink in Wireshark&quot;">​</a></h1><p><a href="https://www.wireshark.org/" target="_blank" rel="noreferrer">Wireshark</a> is an extremely popular &quot;general purpose&quot; network protocol analyzer that can be used to inspect and analyse MAVLink traffic.</p><p>The benefits of using <em>Wireshark</em> over other alternatives are:</p><ul><li>it can view <em>all</em> traffic on a network interface (GCS tools like <a href="https://docs.qgroundcontrol.com/master/en/analyze_view/mavlink_inspector.html" target="_blank" rel="noreferrer">MAVLink Inspector</a> often only analyse incoming traffic).</li><li>you can use it to analyse traffic logged on a companion computer (this allows analysis of traffic between the companion computer and flight controller, which might otherwise not be visible to <em>Wireshark</em>).</li><li>it is easy to update for new custom messages and dialects. Rebuilding <em>QGroundControl</em> so you can use it analyse custom messages is much harder!</li></ul><p>This topic shows how to generate a Wireshark plugin for a particular dialect file and install it on Wireshark, and how to perform basic filtering. It also provides an overview of how you can use <em>tcpdump</em> for collecting traffic on a linux computer (for later analysis).</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>You will need to regenerate and reimport the plugin (as shown below) if your dialect changes.</p></div><h2 id="generate-mavlink-lua-plugin-for-wireshark" tabindex="-1">Generate MAVLink Lua Plugin for Wireshark <a class="header-anchor" href="#generate-mavlink-lua-plugin-for-wireshark" aria-label="Permalink to &quot;Generate MAVLink Lua Plugin for Wireshark&quot;">​</a></h2><p>First you will need to generate a <em>Wireshark</em> plugin that includes definitions for the MAVLink messages that you want it to handle. The MAVLink generator (<strong>mavgen</strong>) can build this plugin for a dialect in the same way as it builds MAVLink libraries for other programming languages.</p><p>The steps are:</p><ol><li><p><a href="./../getting_started/installation.html">Install MAVLink</a> (if you have not already done so).</p></li><li><p>Build libraries for your target dialect, specifing <code>WLua</code> as the target language. This process is described in the topic <a href="./../getting_started/generate_libraries.html">Generate MAVLink Libraries</a>.</p><p>For example, to build the MAVLink 2 Wireshark plugin for <a href="./../messages/common.html">common.xml</a> you might use the following command:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">python3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pymavlink.tools.mavgen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --lang=WLua</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --wire-protocol=2.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --output=mavlink_2_common</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> message_definitions/v1.0/common.xml</span></span></code></pre></div><p>The plugin would be created in the current directory as: <strong>mavlink_2_common.lua</strong>.</p></li></ol><h2 id="update-plugin-with-correct-ports" tabindex="-1">Update Plugin with Correct Ports <a class="header-anchor" href="#update-plugin-with-correct-ports" aria-label="Permalink to &quot;Update Plugin with Correct Ports&quot;">​</a></h2><p>The last few lines of the plugin file specify the ports to be monitored: 14550 and 14580.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-- bind protocol dissector to port 14550 and 14580</span></span>
<span class="line"><span></span></span>
<span class="line"><span>local udp_dissector_table = DissectorTable.get(&quot;udp.port&quot;)</span></span>
<span class="line"><span>udp_dissector_table:add(14550, mavlink_proto)</span></span>
<span class="line"><span>udp_dissector_table:add(14580, mavlink_proto)</span></span></code></pre></div><p>These are the correct ports to monitor network traffic between a simulated autopilot and a GCS and offboard API. The final port (18570) can be used to monitor a simulation running in WSL2.</p><p>If you want to monitor other interfaces then you can modify or add to these lines and then save the plugin file. This might be necessary, for example, in order to monitor traffic recorded on the interface between a companion computer and a flight controller.</p><h2 id="import-lua-plugin-into-wireshark" tabindex="-1">Import Lua Plugin into WireShark <a class="header-anchor" href="#import-lua-plugin-into-wireshark" aria-label="Permalink to &quot;Import Lua Plugin into WireShark&quot;">​</a></h2><p>To import the plugin into <em>Wireshark</em>:</p><ol><li><p>Copy the plugin file into the wireshare plugins directory.</p><ul><li>On Linux systems this might be: <code>~/.local/lib/wireshark/plugins</code> (or <code>~/.wireshark/plugins</code> for older versions of Wireshark). Note that users will need to be added to the <code>wireshark</code> group to use the tool.)</li><li>On Windows this might be: <code>Program Files/Wireshark/plugins</code>.</li></ul></li><li><p>Open <em>Wireshark</em> and follow the menu: <strong>Help &gt; About Wireshark &gt; Plugins</strong></p><p>You should find the plugin in the list. For example, with the plugin created in the previous section you would see <code>mavlink_2_common.lua</code></p></li></ol><h2 id="view-traffic-on-wireshark" tabindex="-1">View Traffic on Wireshark <a class="header-anchor" href="#view-traffic-on-wireshark" aria-label="Permalink to &quot;View Traffic on Wireshark&quot;">​</a></h2><p>Wireshark can inspect any interface on the host computer on which it is running. So you can use it to inspect traffic between a GCS and running on the same computer and a real or simulated computer.</p><p>For example assuming you have a simulator and ground station running on the same computer, select the <strong>Adapter for loopback traffic capture</strong>.</p><p><img src="`+a+'" alt="Wireshark: Select loopback adapter"></p><p>This will display all traffic on the interface. With the MAVLink WLua plugin installed, MAVLink message names are displayed next to each UDP packet that contains a MAVLink message.</p><p><img src="'+t+'" alt="Wireshark: Live unfiltered traffic"></p><p>You can filter to show <em>just</em> the MAVLink traffic using <code>mavlink_proto</code> in the filter box (below we also filter on <code>not icmp</code> to remove additional control packets).</p><p><img src="'+i+'" alt="Wireshark: Live traffic filtered to show only MAVLink packets"></p><p>Click on a particular message to find out its details. Below you can see the payload and the header details for an <code>ATTITUDE_TARGET</code> message:</p><p><img src="'+o+`" alt="Wireshark: Packet details"></p><h2 id="filtering-using-mavlink-properties" tabindex="-1">Filtering using MAVLink Properties <a class="header-anchor" href="#filtering-using-mavlink-properties" aria-label="Permalink to &quot;Filtering using MAVLink Properties&quot;">​</a></h2><p>In addition to using filters for the usual <em>Wireshark</em> things (e.g. ips and ports) you can also use the new MAVLink filters.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>This works the same way for live view and for a <em>pcapng</em> file loaded into <em>Wireshark</em></p></div><p>We already saw you can filter for MAVLink packets using <code>mavlink_proto</code>. The following is a filter example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mavlink_proto.msgid==0 &amp;&amp; mavlink_proto.compid == 1 &amp;&amp;</span></span>
<span class="line"><span>(ip.addr == 10.0.115.155 &amp;&amp; ip.dst == 10.0.115.141)</span></span></code></pre></div><p>This means to filter for:</p><ul><li>Mavlink msgid=<code>HEARTBEAT</code></li><li>Mavlink src compid=<code>AUTOPILOT</code></li><li>src IP=<code>10.0.115.155</code></li><li>dst IP=<code>10.0.115.141</code></li></ul><h2 id="capture-mavlink-stream" tabindex="-1">Capture MAVLink Stream <a class="header-anchor" href="#capture-mavlink-stream" aria-label="Permalink to &quot;Capture MAVLink Stream&quot;">​</a></h2><p>On Linux you can use <em>tcpdump</em> to capture stream on a specific interface. This can be performed either on your laptop or on the offboard computer:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>apt update</span></span>
<span class="line"><span>apt install tcpdump</span></span>
<span class="line"><span>tcpdump -i eth0 -w mavlink-capture.pcap</span></span></code></pre></div><h2 id="capture-tcpdump-mavlink-data-live-from-a-remote-machine-on-a-local-wireshark" tabindex="-1">Capture tcpdump (MAVLink) data live from a remote machine on a local WireShark <a class="header-anchor" href="#capture-tcpdump-mavlink-data-live-from-a-remote-machine-on-a-local-wireshark" aria-label="Permalink to &quot;Capture tcpdump (MAVLink) data live from a remote machine on a local WireShark&quot;">​</a></h2><p><code>tcpdump</code> must be installed on the remote machine.</p><p>When you can access the remote machine with SSH you can stream the tcpdump to your local machine instead of logging it to a file. <em>Wireshark</em> can open this stream and show the decoded MAVLink messages using the tools and filters from above.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mkfifo /tmp/mavlink;</span></span>
<span class="line"><span>wireshark -k -i /tmp/mavlink &amp;</span></span>
<span class="line"><span>ssh root@10.41.1.1 -p 33333 &quot;tcpdump -s 0 -U -n -w - -i lo not port 33333&quot; &gt; /tmp/mavlink;</span></span></code></pre></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Username, IP and port above have to be adjusted to the configuration on the remote machine.</p></div><ol><li><p><code>mkfifo /tmp/mavlink</code> Creates a named pipe that is used to stream the data.</p></li><li><p><code>wireshark -k -i /tmp/mavlink &amp;</code> Start <em>Wireshark</em>, open the named pipe as input and start the capture immediately.</p></li><li><p>Start the data stream on the remote machine and pipe it into the named pipe on your local machine.</p><ul><li><code>-s 0</code> Set snapshot length to default</li><li><code>-U</code> Stream packet output packet-buffered, don’t wait for a full buffer</li><li><code>-n</code> Don&#39;t convert addresses (i.e., host addresses, port numbers, etc.) to names</li><li><code>-w -</code> Write raw data to standard output (piped to the local machine)</li><li><code>-i lo</code> Define which interface to listen on. This will listen to the loopback interface, you can change this to the Ethernet, USB or modem interface.</li><li><code>not port 33333</code> Don’t capture the data created by the SSH session. You can add more filters to tcpdump to reduce the streamed data.</li></ul></li></ol><h2 id="measuring-mavlink-data-rates-using-wireshark" tabindex="-1">Measuring MAVLink data rates using Wireshark <a class="header-anchor" href="#measuring-mavlink-data-rates-using-wireshark" aria-label="Permalink to &quot;Measuring MAVLink data rates using Wireshark&quot;">​</a></h2><p>After the plugin is setup in Wireshark ad you have started to capture a stream you can use the Wireshark IO graphsto monitor message rates for either the whole stream or just specific messages.</p><p>To do this you need to go to <strong>Statistics &gt; I/O Graphs</strong> and you will get a new window. Now you will a plot of the data rate of all packets you are analyzing. You can filter for the usual <em>Wireshark</em> filters and the new MAVLink ones introduced by the LUA script.</p><p>We recommend changing the y axis to bits or bytes and to reduce the x axis to 10ms or faster to get meaningful plots.</p>`,48)]))}const w=s(p,[["render",c]]);export{b as __pageData,w as default};
