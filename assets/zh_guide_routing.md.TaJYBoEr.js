import{_ as t,c as a,a8 as o,o as s}from"./chunks/framework.CnRC9NRC.js";const u=JSON.parse('{"title":"路由","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/routing.md","filePath":"zh/guide/routing.md"}'),n={name:"zh/guide/routing.md"};function i(r,e,d,c,l,m){return s(),a("div",null,e[0]||(e[0]=[o('<h1 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-label="Permalink to &quot;路由&quot;">​</a></h1><p>这个主题解释了如何由 MAVLink 系统路由信息。</p><h2 id="综述" tabindex="-1">综述 <a class="header-anchor" href="#综述" aria-label="Permalink to &quot;综述&quot;">​</a></h2><p>一个 MAVLINK 网络由多种系统组成（无人机、地面站、天线追踪器等），这些系统可能由一个或多个组件（自动试验、相机、服务器等）组成。</p><p>Each system has a network-unique <em>system id</em>, and each component has a system-unique <em>component id</em> that can be used for addressing/routing:</p><ul><li>The <em>system id</em> has a value between 1 and 255. <ul><li>默认自动试验系统 id通常是 1。 用户应在添加新的自动驾驶仪到网络时分配独特增加的 id 值。 用户应在添加新的自动驾驶仪到网络时分配独特增加的 id 值。</li><li>GCS 系统和开发者API 通常在数值范围顶部使用ID，以减少ID冲突(例如：255)。 它们的系统ID经常可用于允许多GCS系统。 它们的系统ID经常可用于允许多GCS系统。</li></ul></li><li>The <em>component id</em> is allocated by type and number from <a href="./../messages/common.html#MAV_COMPONENT">MAV_COMPONENT</a>.</li></ul><p>消息可用于所有系统、特定系统、系统中的所有组件或系统内的特定组件。 协议界定了在报文有效载荷中能够(可选) 指定的两个8位字段，以表明发送/路由。 If the ids are omitted or set to zero then the message is considered a <em>broadcast</em> (intended for all systems/components).</p><ul><li><code>target_system</code>: System that should execute the command</li><li><code>target_component</code>: Component that should execute the command (requires <code>target_system</code>).</li></ul><p>MAVLink组件预计将处理具有匹配系统/组件id和广播信息的信息。 预计他们将转发/重发其他(或所有)收件人的消息，前往其他活动频道（即MAVLink系统可以连接不同的运输系统，连接到连接信息的路线）。 广播消息已转发给所有尚未看到消息的通道。 地址消息在新频道 <em>ff</em>上重新发送，系统以前从该频道的目标中看到了一条消息， (如果收件人不知道，或在原始/接入频道，信息不会重新发送)。 They are expected to route/resend messages that are intended for other (or all) recipients to other active channels (i.e. MAVLink systems may be connected across different transports, connected by a MAVLink system that routes the messages). 广播消息已转发给所有尚未看到消息的通道。 Addressed messages are resent on a new channel <em>iff</em> the system has previously seen a message from the target on that channel (messages are not resent if the addressee is not known or is on the original/incoming channel).</p><div class="warning custom-block github-alert"><p class="custom-block-title">WARNING</p><p>Forwarded messages must not be changed/repackaged by the forwarding system (the original message is passed to the new link).</p></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Systems should, where possible, forward messages according to the routing rules <em>even if they are unable to process them</em> (e.g. signed messages that cannot be authenticated). Messages that are not supported/understood by the library should be forwarded as though they were broadcast messages (in this case the target system/component ids cannot be read).</p></div><h2 id="路由详细信息" tabindex="-1">路由详细信息 <a class="header-anchor" href="#路由详细信息" aria-label="Permalink to &quot;路由详细信息&quot;">​</a></h2><p>Systems/components should process a message locally if any of these conditions hold:</p><ul><li>It is a broadcast message (<code>target_system</code> field omitted or zero).</li><li>The <code>target_system</code> matches its system id and <code>target_component</code> is broadcast (<code>target_component</code> omitted or zero).</li><li>The <code>target_system</code> matches its system id and has the component&#39;s <code>target_component</code></li><li>The <code>target_system</code> matches its system id and the component is unknown (i.e. this component has not seen any messages on any link that have the message&#39;s <code>target_system</code>/<code>target_component</code>).</li></ul><p>Systems should forward messages to another link if any of these conditions hold:</p><ul><li>It is a broadcast message (<code>target_system</code> field omitted or zero).</li><li>The <code>target_system</code> does not match the system id <em>and</em> the system knows the link of the target system (i.e. it has previously seen a message from <code>target_system</code> on the link).</li><li>The <code>target_system</code> matches its system id and has a <code>target_component</code> field, and the system has seen a message from the <code>target_system</code>/<code>target_component</code> combination on the link.</li></ul><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Non-broadcast messages must only be sent (or forwarded) to known destinations (i.e. a system must previously have received a message from the target system/component).</p></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Systems should also check for <code>SYSTEM_TIME</code> messages with a decrease in <code>time_boot_ms</code>, as this indicates that the system has rebooted. In this case it should clear stored routing information (and might perform other actions that are useful following a reboot - e.g. re-fetching parameters and home position etc.).</p></div><h2 id="库支持" tabindex="-1">库支持 <a class="header-anchor" href="#库支持" aria-label="Permalink to &quot;库支持&quot;">​</a></h2><h3 id="c-库-mavgen" tabindex="-1">C 库 (mavgen) <a class="header-anchor" href="#c-库-mavgen" aria-label="Permalink to &quot;C 库 (mavgen)&quot;">​</a></h3><p>The generated code for the MAVLink v1 C Library has no specific support for routing or working with <code>target_system</code> and <code>target_component</code>. To extract this information you will need to use the normal methods provided for reading payload fields, and match on the field names.</p><p>The MAVLink v2 generator for the C library has been updated to make it easier to get the destination system and component ID from the payload (when these are assigned). Specifically, the <code>mavlink_msg_entry_t</code> structure contains flags to tell you if the message contains target system/component information (<code>FLAG_HAVE_TARGET_SYSTEM</code>, <code>FLAG_HAVE_TARGET_COMPONENT</code>) and offsets into the payload that you can use to get these ids (<code>target_system_ofs</code> and <code>target_component_ofs</code>, respectively). The MAVLink helper method <code>const mavlink_msg_entry_t*</code> <a href="https://github.com/mavlink/c_library_v2/blob/master/mavlink_helpers.h" target="_blank" rel="noreferrer"><code>mavlink_get_msg_entry(uint32_t msgid)</code></a> can be used to get this structure from the message id.</p><h2 id="mavlink-2-路由" tabindex="-1">MAVLink 2 路由 <a class="header-anchor" href="#mavlink-2-路由" aria-label="Permalink to &quot;MAVLink 2 路由&quot;">​</a></h2><p>Unsigned MAVLink 2 packets are routed in the same way as MAVLink 1 packets.</p><h2 id="routing_signed_packets" tabindex="-1">Routing Signed Packets <a class="header-anchor" href="#routing_signed_packets" aria-label="Permalink to &quot;Routing Signed Packets {#routing_signed_packets}&quot;">​</a></h2><p>Signed packets should be routed in the same way as any other packet.</p><p>In particular, a routing system should:</p><ul><li>不以任何方式更改电文(包括替换原始签字)。</li><li>即使不能被验证(甚至理解)，因此不能在当地加以处理，也按照正常规则提交信息。</li></ul><h2 id="路由接口" tabindex="-1">路由接口 <a class="header-anchor" href="#路由接口" aria-label="Permalink to &quot;路由接口&quot;">​</a></h2><p>The <a href="https://github.com/mavlink-router/mavlink-router" target="_blank" rel="noreferrer">MAVLink Router</a> can be used to mix-and-match different IP protocols with serial ports in order to route MAVLink traffic.</p><h2 id="更多信息" tabindex="-1">更多信息 <a class="header-anchor" href="#更多信息" aria-label="Permalink to &quot;更多信息&quot;">​</a></h2><ul><li><a href="http://ardupilot.org/dev/docs/mavlink-routing-in-ardupilot.html" target="_blank" rel="noreferrer">MAVLink Routing in ArduPilot</a> (ArduPilot DevGuide)</li></ul>',32)]))}const g=t(n,[["render",i]]);export{u as __pageData,g as default};
