import{_ as t}from"./chunks/timesync_offsets_graph.i4HoUahf.js";import{_ as o,c as s,o as i,al as n}from"./chunks/framework.DM883ANZ.js";const f=JSON.parse('{"title":"Time Synchronization Protocol v2","description":"","frontmatter":{},"headers":[],"relativePath":"en/services/timesync.md","filePath":"en/services/timesync.md"}'),a={name:"en/services/timesync.md"};function r(c,e,m,d,h,l){return i(),s("div",null,[...e[0]||(e[0]=[n('<h1 id="time-synchronization-protocol-v2" tabindex="-1">Time Synchronization Protocol v2 <a class="header-anchor" href="#time-synchronization-protocol-v2" aria-label="Permalink to &quot;Time Synchronization Protocol v2&quot;">​</a></h1><p>This protocol is used to synchronize clocks on MAVLink components by estimating their time offset.</p><p>The protocol uses just one message <a href="#TIMESYNC">TIMESYNC</a>, which has two <code>int64_t</code> fields: <code>tc1</code> and <code>ts1</code>. A component that wants to synchronize clocks sends out a <code>TIMESYNC</code> request with its current timestamp in <code>ts1</code>. A remote system that supports the protocol sends a <code>TIMESYNC</code> response, including both the original timestamp and its own timestamp. The original system can use this information to determine the round-trip time, and estimate the timestamp offset.</p><p>This sequence is run multiple times and filtered/averaged to reduce the transient effects of the channel and processor usage on the offset calculation.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>This version replaces <a href="#time-synchronization-protocol-v1">Time Synchronization Protocol v1</a>.</p></div><h2 id="message-enum-summary" tabindex="-1">Message/Enum Summary <a class="header-anchor" href="#message-enum-summary" aria-label="Permalink to &quot;Message/Enum Summary&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Message</th><th>Description</th></tr></thead><tbody><tr><td><a id="TIMESYNC"></a><a href="./../messages/common.html#TIMESYNC">TIMESYNC</a></td><td>Time synchronization message.</td></tr></tbody></table><h2 id="sequences" tabindex="-1">Sequences <a class="header-anchor" href="#sequences" aria-label="Permalink to &quot;Sequences&quot;">​</a></h2><p><a href="https://mermaid-js.github.io/mermaid-live-editor/edit#pako:eNqFkT1PwzAQhv_KyVMrpYiuQe1SOjDQJSxIWQ77UiwldjifQajqf-eCwwAZ8OL7et_H8l2MjY5MbRK9ZQqW7j2eGYe7NoCeEVm89SMGgUPvKciy3hC_E5f6KQpB1HSerkqzhqeHx2PzfDoAT5wksHrhiM6ihpFBkM8k5NbFpog3-_1CvhK73d1WIGm7C_Fj_RdbBFUx-IVNYwyJ1GBGgcSZM5sU6UapC_U3VXGFW9o3Gv6HLzdY7G3uUSgBxxwUzX4E8QMBaqbf4QecnhS7LpF-sanMQDygd7qZywRpjbzSQK2pNXTUYe6lNW246mgenaqPzktkU3fYJ6oMZonNZ7CmFs70MzRvd566fgHVwK12" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/pako:eNqFkT1PwzAQhv_KyVMrpYiuQe1SOjDQJSxIWQ77UiwldjifQajqf-eCwwAZ8OL7et_H8l2MjY5MbRK9ZQqW7j2eGYe7NoCeEVm89SMGgUPvKciy3hC_E5f6KQpB1HSerkqzhqeHx2PzfDoAT5wksHrhiM6ihpFBkM8k5NbFpog3-_1CvhK73d1WIGm7C_Fj_RdbBFUx-IVNYwyJ1GBGgcSZM5sU6UapC_U3VXGFW9o3Gv6HLzdY7G3uUSgBxxwUzX4E8QMBaqbf4QecnhS7LpF-sanMQDygd7qZywRpjbzSQK2pNXTUYe6lNW246mgenaqPzktkU3fYJ6oMZonNZ7CmFs70MzRvd566fgHVwK12" alt="Mermaid sequence: Time sync"></a></p><p>The sequence is:</p><ol><li><p>A component that needs time synchronization sends a <code>TIMESYNC</code> request that includes its current nanosecond timestamp in <code>ts1</code> (and <code>tc1 = 0</code>, indicating it is a request). This message may be broadcast, or targeted to a particular component.</p></li><li><p>A component that receives a <code>TIMESYNC</code> request (<code>TIMESYNC.tc1 == 0</code>) responds with a <code>TIMESYNC</code> response (<code>tc1 ≠ 0</code>) that includes the original timestamp from the request in <code>ts1</code> (mirrored), and its own timestamp in <code>tc1</code>.</p></li><li><p>When the synchronizing component gets a <code>TIMESYNC</code> response with its own <code>target_system</code> and <code>target_component</code> it knows it is a reply to a timesync request that it sent.</p><p>From the message the system can:</p><ul><li>determine the round trip time (by comparing its current timestamp with the original stamp that was returned in the message in <code>ts1</code>).</li><li>estimate the offset between system timestamps, using the round trip time and the timestamp sent back by the remote system.</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>TIMESYNC` responses to the broadcast address indicate that the remote system supports <a href="#time-synchronization-protocol-v1">Time Synchronization Protocol v1</a>. Synchronization may be unreliable if there are multiple synchronising components on the network (report/log an error and upgrade the remote system). The component should ignore responses to all other addresses.</p></div></li></ol><p>The offset is an estimate because the time spent, both inbound and outbound, will change over time based on things like link congestion and processing time. Therefore the above sequence might be run a significant number of times, and filtering used to remove outlying estimates.</p><p>A graph showing the &quot;noise&quot; when estimating the offset is given below (from PX4).</p><p><img src="'+t+'" alt="Timesync offsets"></p><h2 id="time-synchronization-protocol-v1" tabindex="-1">Time Synchronization Protocol v1 <a class="header-anchor" href="#time-synchronization-protocol-v1" aria-label="Permalink to &quot;Time Synchronization Protocol v1&quot;">​</a></h2><p>Version 1 of the timesync protocol uses the same message and sequences as version 2.</p><p>The difference is the <code>TIMESYNC</code> message in version 1 did not have <code>target_system</code> and <code>target_component</code> fields, and so the message was always broadcast. This could result in unreliable timesync if there are multiple synchronizing components on the network, because there is no way for a component to know whether a <code>TIMESYNC</code> response is to its request.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>ArduPilot encodes the system id in <code>TIMESYNC.ts1</code> of the request. This allows filtering of the response to a particular system (but not component), reducing the risk of clashes.</p></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Version 2 makes adds the target address, so a syncing system can filter on just the responses to its requests.</p></div><h2 id="implementations" tabindex="-1">Implementations <a class="header-anchor" href="#implementations" aria-label="Permalink to &quot;Implementations&quot;">​</a></h2><ul><li>PX4: <a href="https://github.com/PX4/PX4-Autopilot/blob/master/src/modules/mavlink/mavlink_timesync.cpp" target="_blank" rel="noreferrer">/src/modules/mavlink/mavlink_timesync.cpp</a></li></ul>',21)])])}const g=o(a,[["render",r]]);export{f as __pageData,g as default};
