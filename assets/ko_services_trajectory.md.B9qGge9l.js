import{_ as t,c as a,a8 as o,o as n}from"./chunks/framework.CnRC9NRC.js";const m=JSON.parse('{"title":"Path Planning Protocol (Trajectory Interface)","description":"","frontmatter":{},"headers":[],"relativePath":"ko/services/trajectory.md","filePath":"ko/services/trajectory.md"}'),i={name:"ko/services/trajectory.md"};function r(s,e,c,l,p,h){return n(),a("div",null,e[0]||(e[0]=[o('<h1 id="path-planning-protocol-trajectory-interface" tabindex="-1">Path Planning Protocol (Trajectory Interface) <a class="header-anchor" href="#path-planning-protocol-trajectory-interface" aria-label="Permalink to &quot;Path Planning Protocol (Trajectory Interface)&quot;">​</a></h1><p>The path planning protocol (a.k.a. trajectory interface) is a general-purpose protocol for a system to request dynamic path planning from another system (i.e. for an autopilot to request a path from a companion computer).</p><p>The protocol is primarily intended for cases where constraints on the path to a destination are unknown or may change dynamically, but it can also be used for any other path management activities. Examples include: <em>obstacle avoidance</em> when following a preplanned mission, determining paths for self forming/healing swarms, offloading geofence management to a companion computer, etc.</p><h2 id="개요" tabindex="-1">개요 <a class="header-anchor" href="#개요" aria-label="Permalink to &quot;개요&quot;">​</a></h2><p>The (autopilot) system that requires path-planning sends messages containing its current position and desired trajectory. The path planning system (companion computer) analyses the desired route, and sends back a stream of messages with setpoints for a new path.</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEF1dG9waWxvdFxuICAgIHBhcnRpY2lwYW50IENvbXBhbmlvblxuICAgIEF1dG9waWxvdC0-PkNvbXBhbmlvbjogRGVzaXJlZCBwYXRoL3RyYWplY3RvcnlcbiAgICBDb21wYW5pb24tPj5Db21wYW5pb246IENhbGN1bGF0ZSBiZXN0IHRyYWplY3RvcnlcbiAgICBDb21wYW5pb24tLT4-QXV0b3BpbG90OiBUYXJnZXQgc2V0cG9pbnQgKGlmIHJlcXVpcmVkKSIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEF1dG9waWxvdFxuICAgIHBhcnRpY2lwYW50IENvbXBhbmlvblxuICAgIEF1dG9waWxvdC0-PkNvbXBhbmlvbjogRGVzaXJlZCBwYXRoL3RyYWplY3RvcnlcbiAgICBDb21wYW5pb24tPj5Db21wYW5pb246IENhbGN1bGF0ZSBiZXN0IHRyYWplY3RvcnlcbiAgICBDb21wYW5pb24tLT4-QXV0b3BpbG90OiBUYXJnZXQgc2V0cG9pbnQgKGlmIHJlcXVpcmVkKSIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9" alt="Mermaid Sequence: Trajectory"></a></p><p>When path planning is active, autopilots are expected to navigate using the most recent setpoint from the companion computer (and should have sensible behaviour if setpoints &quot;run out&quot;).</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>The path planning system might send setpoints all the time, or only when a desired trajectory cannot be achieved (this depends on the specific service implementation).</p></div><p>The protocol defines two messages:</p><ul><li><a href="./../messages/common.html#TRAJECTORY_REPRESENTATION_WAYPOINTS">TRAJECTORY_REPRESENTATION_WAYPOINTS</a> - Trajectory represented as an array of up-to 5 <em>waypoints</em> in the <em>local frame</em>.</li><li><a href="./../messages/common.html#TRAJECTORY_REPRESENTATION_BEZIER">TRAJECTORY_REPRESENTATION_BEZIER</a> - Trajectory represented using an array of up-to 5 bezier points in the local frame.</li></ul><p>Either message may be used to represent both the desired trajectory and the target setpoint, and a system may support either or both messages.</p><p>When specifying a desired path (using either message):</p><ul><li>The first point (0th array index) always represents the current position/state of the vehicle. <ul><li>For waypoint trajectories the current position usually needs either <code>position</code> or <code>velocity</code> fields, and either <code>yaw</code> or <code>yaw_speed</code> (not all of them)</li></ul></li><li>It may not be necessary to specify a waypoint or curve point for every array index. <ul><li>For waypoint trajectories you might only need to specify points for the current position, current waypoint, and the next waypoint.</li></ul></li><li>It may not be necessary to set a value for every field in a waypoint.</li><li>Array indexes and field values that are not used should be set as NaN.</li></ul><p>When specifying a target setpoint, the values should be set in the first point of the message (0th array element). All other array fields should be set to NaN.</p><p>The required message sending update rate depends on the speed of the vehicle and use case.</p><h2 id="구현" tabindex="-1">구현 <a class="header-anchor" href="#구현" aria-label="Permalink to &quot;구현&quot;">​</a></h2><h3 id="obstacle-avoidance-in-px4-mission-mode" tabindex="-1">Obstacle Avoidance in PX4 Mission Mode <a class="header-anchor" href="#obstacle-avoidance-in-px4-mission-mode" aria-label="Permalink to &quot;Obstacle Avoidance in PX4 Mission Mode&quot;">​</a></h3><p>The protocol has been used to provide obstacle avoidance in PX4&#39;s mission mode. PX4 sends the current position, current waypoint, and next waypoint in a <code>TRAJECTORY_REPRESENTATION_WAYPOINTS</code> message (at 5Hz). The path planning software (a ROS node) sends setpoints for the duration of the mission. These navigate the vehicle in a straight line to each waypoint, navigating around obstacles as needed.</p><p>For more information see: <a href="https://docs.px4.io/en/computer_vision/obstacle_avoidance.html" target="_blank" rel="noreferrer">Obstacle Avoidance</a> (PX4 User Guide).</p>',19)]))}const u=t(i,[["render",r]]);export{m as __pageData,u as default};
