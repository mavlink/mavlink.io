import{_ as t}from"./chunks/ftp_transfer_payload_data_qgc.BN0x4DF_.js";import{_ as o,c as i,a8 as a,o as s}from"./chunks/framework.CnRC9NRC.js";const f=JSON.parse('{"title":"File Transfer Protocol (FTP)","description":"","frontmatter":{},"headers":[],"relativePath":"zh/services/ftp.md","filePath":"zh/services/ftp.md"}'),r={name:"zh/services/ftp.md"};function d(n,e,l,c,h,m){return s(),i("div",null,e[0]||(e[0]=[a('<h1 id="file-transfer-protocol-ftp" tabindex="-1">File Transfer Protocol (FTP) <a class="header-anchor" href="#file-transfer-protocol-ftp" aria-label="Permalink to &quot;File Transfer Protocol (FTP)&quot;">​</a></h1><p>Developers can read the Internet protocol RFCs to understand MAVLink FTP. <strong>Note</strong> MAVLink FTP implementation closely follows the design of the original internet <a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">FTP protocol</a> in terms of the message structure, sequences, and the supported opcodes/operations.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>MAVLink FTP implementation closely follows the design of the original internet <a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol" target="_blank" rel="noreferrer">FTP protocol</a> in terms of the message structure, sequences, and the supported opcodes/operations. The File Transfer Protocol (FTP) enables file transfer over MAVLink.</p></div><p>The protocol follows a client-server pattern, where all commands are sent by the GCS (client), and the Drone (server) responds either with an ACK containing the requested information, or a NAK containing an error. The GCS sets a timeout after most commands, and may resend the command if it is triggered. The drone must re-send its response if a request with the same sequence number is received.</p><p>All messages (commands, ACK, NAK) are exchanged inside <a href="./../messages/common.html#FILE_TRANSFER_PROTOCOL">FILE_TRANSFER_PROTOCOL</a> messages. This message type definition is minimal, with fields for specifying the target network, system and component, and for an &quot;arbitrary&quot; variable-length payload.</p><p>The different commands and other information required to implement the protocol are encoded <em>within</em> in the <code>FILE_TRANSFER_PROTOCOL</code> payload. This topic explains the encoding, packing format, commands and errors, and the order in which the commands are sent to implement the core FTP functionality.</p><h2 id="protocol-discovery" tabindex="-1">Protocol Discovery <a class="header-anchor" href="#protocol-discovery" aria-label="Permalink to &quot;Protocol Discovery&quot;">​</a></h2><p>FTP (v1) is supported if the <a href="./../messages/common.html#AUTOPILOT_VERSION">AUTOPILOT_VERSION.capability</a> field has the <a href="./../messages/common.html#MAV_PROTOCOL_CAPABILITY_FTP">MAV_PROTOCOL_CAPABILITY_FTP</a> flag set.</p><p>This flag should only be set by a MAVLink component that supports the specific version of the protocol defined in this document.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>The encoding and content of the <code>FILE_TRANSFER_PROTOCOL</code> payload field are not mandated by the specification, and other encoding schemes might be used, for example, in private networks. If you have implemented a private encoding or different version you <strong>must not</strong> set the <a href="./../messages/common.html#MAV_PROTOCOL_CAPABILITY_FTP">MAV_PROTOCOL_CAPABILITY_FTP</a> flag.</p></div><h2 id="payload" tabindex="-1">Payload Format <a class="header-anchor" href="#payload" aria-label="Permalink to &quot;Payload Format {#payload}&quot;">​</a></h2><p>The <code>FILE_TRANSFER_PROTOCOL</code> payload is encoded with the information required for the various FTP messages. This includes fields for holding the command that is being sent, the sequence number of the current FTP message (for multi-message data transfers), the size of information in the data part of the message etc.</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>Readers will note that the FTP payload format is very similar to the packet format used for serializing MAVLink itself.</p></div><p>Below is the over-the-wire format for the payload part of the <a href="./../messages/common.html#FILE_TRANSFER_PROTOCOL">FILE_TRANSFER_PROTOCOL</a> message on PX4/<em>QGroundControl</em>.</p><p><img src="'+t+'" alt="FILETRANSFERPROTOCOL Payload format - QGC"></p><table tabindex="0"><thead><tr><th>字节索引</th><th>C 版本</th><th>内容</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>0 to 1</td><td><code>uint16_t seq_number</code></td><td>Sequence number for message</td><td>0&amp;nbsp;-&amp;nbsp;65535</td><td>All <em>new</em> messages between the GCS and drone iterate this number. Re-sent commands/ACK/NAK should use the previous response&#39;s sequence number.</td></tr><tr><td>2</td><td><code>uint8_t session</code></td><td>Session id</td><td>0 - 255</td><td>Session id for read/write operations (the server may use this to reference the file handle and information about the progress of read/write operations).</td></tr><tr><td>3</td><td><code>uint8_t opcode</code></td><td><a href="#opcodes">OpCode</a> (id)</td><td>0 - 255</td><td>Ids for particular commands and ACK/NAK messages.</td></tr><tr><td>4</td><td><code>uint8_t size</code></td><td>Size</td><td>0 - 255</td><td>Depends on <a href="#opcodes">OpCode</a>. For Reads/Writes this is the size of the <code>data</code> transported. For NAK it is the number of bytes used for <a href="#error_codes">error information</a> (1 or 2).</td></tr><tr><td>5</td><td><code>uint8_t req_opcode</code></td><td>Request <a href="#opcodes">OpCode</a></td><td>0 - 255</td><td>OpCode (of original message) returned in an ACK or NAK response.</td></tr><tr><td>6</td><td><code>uint8_t burst_complete</code></td><td>Burst complete</td><td>0, 1</td><td>Code to indicate if a burst is complete. 1: set of burst packets complete, 0: More burst packets coming.<br>- Only used if <code>req_opcode</code> is <a href="#BurstReadFile">BurstReadFile</a>.</td></tr><tr><td>7</td><td><code>uint8_t padding</code></td><td>Padding</td><td></td><td>32 bit alignment padding.</td></tr><tr><td>8 to 11</td><td><code>uint32_t offset</code></td><td>Content offset</td><td></td><td>Offsets into data to be sent for <a href="#ListDirectory">ListDirectory</a> and <a href="#ReadFile">ReadFile</a> commands.</td></tr><tr><td>12 to (max) 251</td><td><code>uint8_t data[]</code></td><td>数据</td><td></td><td>Command/response data. Varies by <a href="#opcodes">OpCode</a>. This contains the <code>path</code> for operations that act on a file or directory. For an ACK for a read or write this is the requested information. For an ACK for a <code>OpenFileRO</code> operation this is the size of the file that was opened. For a NAK the first byte is the <a href="#error_codes">error code</a> and the (optional) second byte may be an error number.</td></tr></tbody></table><h2 id="opcodes" tabindex="-1">OpCodes/Command <a class="header-anchor" href="#opcodes" aria-label="Permalink to &quot;OpCodes/Command {#opcodes}&quot;">​</a></h2><p>The opcodes that may be sent by the GCS (client) to the drone (server) are listed below.</p><table tabindex="0"><thead><tr><th>Opcode</th><th>Name</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>None</td><td>Ignored, always ACKed</td></tr><tr><td><a id="TerminateSession"></a> 1</td><td>TerminateSession</td><td>Terminates open Read <code>session</code>.<br>- Closes the file associated with (<code>session</code>) and frees the session ID for re-use.</td></tr><tr><td><a id="ResetSessions"></a> 2</td><td>ResetSessions</td><td>Terminates <em>all</em> open read sessions.<br>- Clears all state held by the drone (server); closes all open files, etc.<br>- Sends an ACK reply with no data. </td></tr><tr><td><a id="ListDirectory"></a> 3</td><td><a href="#list_directory">ListDirectory</a></td><td>List directory entry information (files, folders etc.) in <code>&lt;path&gt;</code>, starting from a specified entry index (<code>&lt;offset&gt;</code>).<br>- Response is an ACK packet with one or more entries on success, otherwise a NAK packet with an error code.<br>- Completion is indicated by a NACK with EOF in response to a requested index (<code>offset</code>) beyond the list of entries.<br>- The directory is closed after the operation, so this leaves no state on the server.</td></tr><tr><td><a id="OpenFileRO"></a> 4</td><td><a href="#reading-a-file">OpenFileRO</a></td><td>Opens file at <code>&lt;path&gt;</code> for reading, returns <code>&lt;session&gt;</code><br>- The <code>path</code> is stored in the <a href="#payload">payload</a> <code>data</code>. The drone opens the file (<code>path</code>) and allocates a <em>session number</em>. The file must exist.<br>- An ACK packet must include the allocated <code>session</code> and the data size of the file to be opened (<code>size</code>)<br>- A NAK packet must contain <a href="#error_codes">error information</a> . Typical error codes for this command are <code>NoSessionsAvailable</code>, <code>FileExists</code>. <br>- The file remains open after the operation, and must eventually be closed by <code>Reset</code> or <code>Terminate</code>.</td></tr><tr><td><a id="ReadFile"></a> 5</td><td><a href="#reading-a-file-readfile">ReadFile</a></td><td>Reads <code>&lt;size&gt;</code> bytes from <code>&lt;offset&gt;</code> in <code>&lt;session&gt;</code>.<br>- Seeks to (<code>offset</code>) in the file opened in (session) and reads (<code>size</code>) bytes into the result buffer.<br>- Sends an ACK packet with the result buffer on success, otherwise a NAK packet with an error code. For short reads or reads beyond the end of a file, the (<code>size</code>) field in the ACK packet will indicate the actual number of bytes read.<br>- Reads can be issued to any offset in the file for any number of bytes, so reconstructing portions of the file to deal with lost packets should be easy.<br>- For best download performance, try to keep two <code>Read</code> packets in flight.</td></tr><tr><td><a id="CreateFile"></a> 6</td><td><code>CreateFile</code></td><td>Creates file at <code>&lt;path&gt;</code> for writing, returns <code>&lt;session&gt;</code>.<br>- Creates the file (path) and allocates a <em>session number</em>. All parent directories must exist. If the file already existed, then this call will truncate it. Equivalent UNIX flags: (O_CREAT | O_TRUNC | O_WRONLY)<br>- Sends an ACK packet with the allocated session number on success, or a NAK packet with an error code on error (i.e. <a href="#FileExists">FileExists</a> if the <code>path</code> already exists).<br>- The file remains open after the operation, and must eventually be closed by <code>Reset</code> or <code>Terminate</code>.</td></tr><tr><td><a id="WriteFile"></a> 7</td><td><code>WriteFile</code></td><td>Writes <code>&lt;size&gt;</code> bytes to <code>&lt;offset&gt;</code> in <code>&lt;session&gt;</code>.<br>- Sends an ACK reply with no data on success, otherwise a NAK packet with an error code.</td></tr><tr><td><a id="RemoveFile"></a> 8</td><td><a href="#remove-file">RemoveFile</a></td><td>Remove file at <code>&lt;path&gt;</code>.<br>- ACK reply with no data on success.<br>- NAK packet with <a href="#error_codes">error information</a> on failure.</td></tr><tr><td><a id="CreateDirectory"></a> 9</td><td><a href="#create-directory">CreateDirectory</a></td><td>Creates directory at <code>&lt;path&gt;</code>.<br>- Sends an ACK reply with no data on success, otherwise a NAK packet with an error code.</td></tr><tr><td><a id="RemoveDirectory"></a> 10</td><td><a href="#remove-directory">RemoveDirectory</a></td><td>Removes directory at <code>&lt;path&gt;</code>. The directory must be empty. Sends an ACK reply with no data on success, otherwise a NAK packet with an error code.</td></tr><tr><td><a id="OpenFileWO"></a> 11</td><td>OpenFileWO</td><td>Opens file at <code>&lt;path&gt;</code> for writing, returns <code>&lt;session&gt;</code>. <br>- Opens the file (<code>path</code>) and allocates a <em>session number</em>. The file will be created if it does not exist. Equivalent UNIX flags: (O_CREAT | O_WRONLY)<br>- Sends an ACK packet with the allocated <em>session number</em> on success, otherwise a NAK packet with an error code.<br>- The file remains open after the operation, and must eventually be closed by <code>Reset</code> or <code>Terminate</code>.</td></tr><tr><td><a id="TruncateFile"></a> 12</td><td><a href="#truncate-file">TruncateFile</a></td><td>Truncate file at <code>&lt;path&gt;</code> to <code>&lt;offset&gt;</code> length.<br>- Sends an ACK reply with no data on success, otherwise a NAK packet with an error code.</td></tr><tr><td><a id="Rename"></a> 13</td><td>Rename</td><td>Rename <code>&lt;path1&gt;</code> to <code>&lt;path2&gt;</code>.<br>- Sends an ACK reply the no data on success, otherwise a NAK packet with an error code (i.e. if the source path does not exist).</td></tr><tr><td><a id="CalcFileCRC32"></a> 14</td><td>| | <a id="CalcFileCRC32"></a> 14 | CalcFileCRC32 | Calculate CRC32 for file at <code>&lt;path&gt;</code>.</td><td>Calculate CRC32 for file at <code>&lt;path&gt;</code>.<br>- Sends an ACK reply with the checksum on success, otherwise a NAK packet with an error code.</td></tr><tr><td><a id="BurstReadFile"></a> 15</td><td><a href="#reading-a-file-burstreadfile">BurstReadFile</a></td><td>| | <a id="BurstReadFile"></a> 15 | <a href="#reading-a-file-burstreadfile">BurstReadFile</a> | Burst-read parts of a file. Messages in the burst are streamed (without ACK) until the burst is complete (as indicated by the field <code>burst_complete</code> being set to <code>1</code>). Parts of a burst that are dropped may be fetched using <a href="#ReadFile">ReadFile</a>.</td></tr></tbody></table><p>The drone (server) will respond with/send the following opcodes for any of the above messages (ACK response on success or a NAK in the event of an error).</p><table tabindex="0"><thead><tr><th>Opcode</th><th>Name</th><th>描述</th></tr></thead><tbody><tr><td>128</td><td>ACK</td><td>ACK response.</td></tr><tr><td>129</td><td>NAK</td><td>NAK response.</td></tr></tbody></table><p>Notes:</p><ul><li>An ACK response may additionally return requested data in the payload (e.g. <code>OpenFileRO</code> returns the session and file size, <code>ReadFile</code> returns the requested file data, etc.).</li><li>The NAK response includes <a href="#error_codes">error information</a> in the payload <code>data</code>.</li></ul><h2 id="error_codes" tabindex="-1">NAK Error Information <a class="header-anchor" href="#error_codes" aria-label="Permalink to &quot;NAK Error Information {#error_codes}&quot;">​</a></h2><p>NAK responses must include one of the errors codes listed below in the <a href="#payload">payload</a> <code>data[0]</code> field.</p><p>An appropriate error code must be used if one is defined. If no appropriate error code exists, the Drone (server) may respond with <a href="#Fail">Fail</a> or <a href="#FailErrno">FailErrno</a>.</p><p>If the error code is <code>FailErrno</code>, then <code>data[1]</code> must additionally contain an error number. This error number is a file-system specific error code (understood by the server).</p><p>The payload <code>size</code> field must be set to either 1 or 2, depending on whether or not <code>FailErrno</code> is specified.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>These are <strong>errors</strong>. Normally if the GCS receives an error it should not attempt to continue the FTP operation, but instead return to an idle state.</p></div><table tabindex="0"><thead><tr><th>Error</th><th>Name</th><th>描述</th></tr></thead><tbody><tr><td><a id="None"></a>0</td><td>None</td><td>No error</td></tr><tr><td><a id="Fail"></a>1</td><td>Fail</td><td>Unknown failure</td></tr><tr><td><a id="FailErrno"></a>2</td><td>FailErrno</td><td>Command failed, Err number sent back in <code>PayloadHeader.data[1]</code>. This is a file-system error number understood by the server operating system.</td></tr><tr><td><a id="InvalidDataSize"></a>3</td><td>InvalidDataSize</td><td>Payload <code>size</code> is invalid</td></tr><tr><td><a id="InvalidSession"></a>4</td><td>InvalidSession</td><td>Session is not currently open</td></tr><tr><td><a id="NoSessionsAvailable"></a>5</td><td>NoSessionsAvailable</td><td>All available sessions are already in use.</td></tr><tr><td><a id="EOF"></a>6</td><td>EOF</td><td>Offset past end of file for <code>ListDirectory</code> and <code>ReadFile</code> commands.</td></tr><tr><td><a id="UnknownCommand"></a>7</td><td>UnknownCommand</td><td>Unknown command / opcode</td></tr><tr><td><a id="FileExists"></a>8</td><td>FileExists</td><td>File/directory already exists</td></tr><tr><td><a id="FileProtected"></a>9</td><td>FileProtected</td><td>File/directory is write protected</td></tr><tr><td><a id="FileNotFound"></a>10</td><td>FileNotFound</td><td>File/directory not found</td></tr></tbody></table><h2 id="timeouts" tabindex="-1">Timeouts/Resending <a class="header-anchor" href="#timeouts" aria-label="Permalink to &quot;Timeouts/Resending {#timeouts}&quot;">​</a></h2><p>The GCS (client) starts a timeout after most commands are sent (these are cleared if an ACK/NAK is received).</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Timeouts may not be set for some messages. For example, a timeout need not set for <a href="#ResetSessions">ResetSessions</a> as the message should always succeed.</p></div><p>If a timeout activates either the command or its response is assumed to have been lost, and the command should be re-sent with the same sequence number etc. A number of retries are allowed, after which the GCS should fail the whole download and reset to an idle state.</p><p>If the drone (client) receives a message with the same sequence number then it assumes that its ACK/NAK response was lost. In this case it should resend the response (the sequence number is not iterated, because it is as though the previous response was not sent).</p><p>The drone has no timeout mechanism; it only ever responds to commands and does not expect any responses.</p><p>GCS recommended settings:</p><ul><li>ACK/NAK timeout: 50 milliseconds</li><li>Command retries: 6</li></ul><h2 id="ftp-operations" tabindex="-1">FTP Operations <a class="header-anchor" href="#ftp-operations" aria-label="Permalink to &quot;FTP Operations&quot;">​</a></h2><h3 id="reading-a-file-readfile" tabindex="-1">Reading a File (<code>ReadFile</code>) <a class="header-anchor" href="#reading-a-file-readfile" aria-label="Permalink to &quot;Reading a File (`ReadFile`)&quot;">​</a></h3><p>After opening a file session, <a href="#ReadFile">ReadFile</a> is called to request a message sized chunk of the file, which is then returned to the client in an <code>ACK</code> message. The process is repeated at different offsets until the whole file has been retrieved. The file session is then closed.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><a href="#reading-a-file-burstreadfile">Burst reading a file</a> is a (generally) faster alternative to this approach.</p></div><p>The sequence of operations for downloading (reading) a file using [ReadFile] is shown below. This assumes that there are no timeouts and all operations/requests succeed.</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgTm90ZSByaWdodCBvZiBHQ1M6IE9wZW4gZmlsZVxuICAgIEdDUy0-PkRyb25lOiAgT3BlbkZpbGVSTyggZGF0YVswXT1wYXRoLCBzaXplPWxlbihwYXRoKSApXG4gICAgRHJvbmUtLT4-R0NTOiBBQ0soIHNlc3Npb24sIHNpemU9NCwgZGF0YT1sZW4oZmlsZSkgKVxuICAgIE5vdGUgcmlnaHQgb2YgR0NTOiBSZWFkIGZpbGUgaW4gY2h1bmtzPGJyPihjYWxsIGF0IG9mZnNldClcbiAgICBHQ1MtPj5Ecm9uZTogIFJlYWRGaWxlKHNlc3Npb24sIHNpemUsIG9mZnNldClcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSyhzZXNzaW9uLCBzaXplPWxlbihidWZmZXIpLCBkYXRhWzBdPWJ1ZmZlcilcbiAgICBOb3RlIHJpZ2h0IG9mIEdDUzogQ29udGludWUgdW50aWwgTkFLPGJyPiB3aXRoIEVPRlxuICAgIERyb25lLS0-PkdDUzogTkFLKHNlc3Npb24sIHNpemU9MSwgZGF0YT1FT0YpXG4gICAgTm90ZSByaWdodCBvZiBHQ1M6IENsb3NlIHNlc3Npb25cbiAgICBHQ1MtPj5Ecm9uZTogIFRlcm1pbmF0ZVNlc3Npb24oc2Vzc2lvbilcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSygpIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgTm90ZSByaWdodCBvZiBHQ1M6IE9wZW4gZmlsZVxuICAgIEdDUy0-PkRyb25lOiAgT3BlbkZpbGVSTyggZGF0YVswXT1wYXRoLCBzaXplPWxlbihwYXRoKSApXG4gICAgRHJvbmUtLT4-R0NTOiBBQ0soIHNlc3Npb24sIHNpemU9NCwgZGF0YT1sZW4oZmlsZSkgKVxuICAgIE5vdGUgcmlnaHQgb2YgR0NTOiBSZWFkIGZpbGUgaW4gY2h1bmtzPGJyPihjYWxsIGF0IG9mZnNldClcbiAgICBHQ1MtPj5Ecm9uZTogIFJlYWRGaWxlKHNlc3Npb24sIHNpemUsIG9mZnNldClcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSyhzZXNzaW9uLCBzaXplPWxlbihidWZmZXIpLCBkYXRhWzBdPWJ1ZmZlcilcbiAgICBOb3RlIHJpZ2h0IG9mIEdDUzogQ29udGludWUgdW50aWwgTkFLPGJyPiB3aXRoIEVPRlxuICAgIERyb25lLS0-PkdDUzogTkFLKHNlc3Npb24sIHNpemU9MSwgZGF0YT1FT0YpXG4gICAgTm90ZSByaWdodCBvZiBHQ1M6IENsb3NlIHNlc3Npb25cbiAgICBHQ1MtPj5Ecm9uZTogIFRlcm1pbmF0ZVNlc3Npb24oc2Vzc2lvbilcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSygpIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0" alt="Mermaid Sequence: Reading a File"></a></p><p>The sequence of operations is:</p><ol><li>GCS (client) sends <a href="#OpenFileRO">OpenFileRO</a> command specifying the file path to open. <ul><li>The payload must specify: <code>data[0]</code>= file path string, <code>size</code>=length of file path string.</li></ul></li><li>Drone (server) responds with either <ul><li>ACK on success. The <a href="#payload">payload</a> must specify fields: <code>session</code> = file session id, <code>size</code> = 4, <code>data</code> = length of file that has been opened.</li><li>NAK with <a href="#error_codes">error information</a>, e.g. <code>NoSessionsAvailable</code>, <code>FileExists</code>. The GCS may cancel the operation, depending on the error.</li></ul></li><li>GCS sends <a href="#ReadFile">ReadFile</a> commands to download a chunk of data from the file. <ul><li>The payload must specify: <code>session</code>=current session, <code>size</code>=size of data to read, <code>offset</code>= position in data to start reading</li></ul></li><li>Drone responds to each message with either <ul><li>ACK on success. The <a href="#payload">payload</a> fields are: <code>data</code> = data chunk requested, <code>size</code> = size of data in the <code>data</code> field.</li><li>NAK on failure with <a href="#error_codes">error information</a>.</li></ul></li><li>The ReadFile/ACK sequence above is repeated at different offsets to download the whole file. <ul><li>Eventually the GCS will (must) request an offset past the end of the file.</li><li>The Drone will return a NAK with error code EOF. The GCS uses this message to recognise the download is complete.</li></ul></li><li>GCS sends <a href="#TerminateSession">TerminateSession</a> to close the file. The drone should send an ACK/NAK, but this may (generally speaking) be ignored by the GCS.</li></ol><p>The GSC should create a timeout after <code>OpenFileRO</code> and <code>ReadFile</code> commands are sent and resend the messages as needed (and <a href="#timeouts">described above</a>). A timeout is not set for <code>TerminateSession</code> (the server may ignore failure of the command or the ACK).</p><h3 id="reading-a-file-burstreadfile" tabindex="-1">Reading a File (<code>BurstReadFile</code>) <a class="header-anchor" href="#reading-a-file-burstreadfile" aria-label="Permalink to &quot;Reading a File (`BurstReadFile`)&quot;">​</a></h3><p>After opening a file for reading, it is read in &quot;bursts&quot;. Each burst delivers a part of the file as a stream of messages. The last message in the burst is indicated by setting <code>burst_complete=1</code> (without any ACKs).</p><p>The client tracks the recieved chunks. On completion of the burst (or the file), if there are any missing parts of the file it can request them using either another burst or using <a href="#reading-a-file-readfile">ReadFile</a>.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Burst read is a (generally) faster alternative to using <a href="#ReadFile">ReadFile</a> to <a href="#reading-a-file-readfile">read a file</a>. This is because fewer messages are sent and need to be waited on.</p></div><p>The sequence of operations for a burst read is shown below (assuming there are no timeouts and all operations/requests succeed).</p><p><a href="pako:eNqlVE1v2zAM_SuETw7gBimwk7cE2NL1MmAFkt2WwVBkOhYmS55EL-iK_vdRlp1kLZIVbQ6xJX48vkfSD4m0JSZ54vFXh0bijRI7J5r3GwP8a4UjJVUrDMFSKzT0_H6N7je6eP_VEoLl4-CdRWMOdy0aqJRGSCvrYNs5T-BQlMrsJiexTu1qAlsN8TmsQl3sa8cE0TmarxaLEaBHuGX76i6FUpD4PvsxbwXVGXj1B-caTRqOExjgYuAVpxihPi6_pODRe2XNEPUu63P10QH8EH2W6Io5AdUYySoTqXpIHbYoCEadYYva7oFvDO6ZcOWR_IuUOGrXtyG4HPBSBqRaeZDCY0geE89nk3OyfQrZQtFBuxP6Y-AgRFChaNEVEf20UI1VX8SYMj7BE5fY-F6_oIOsO_PTh5qUkWzy3PmRN-wV1ZFYIW3TaiSczy716VDn06BnlYfWbbuqQjfJDoMxXLwN4YPsnGP_gs9IizfgTafTC4Le8sJowao3XJLYHaeKu0VPy7t-DafrI6f4ZEpFgCwGx9C7lxO8vBzC3EOjfN__MMAeuv79n0mE9LAoYsupJsAijMb_oCy15eEfuMK-xvBn9bAi0mqNkrA8txHf0DXKCMJ1zDCqdnFa2JhkScOhQpX8OX0IzpuEF7PBTZLza4mV6DRtko15ZNeuZenwc6nIuiSvhPaYJaIju743MsnJdTg6DZ_kwevxL7_b9qs" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/pako:eNqlVE1v2zAM_SuETw7gBimwk7cE2NL1MmAFkt2WwVBkOhYmS55EL-iK_vdRlp1kLZIVbQ6xJX48vkfSD4m0JSZ54vFXh0bijRI7J5r3GwP8a4UjJVUrDMFSKzT0_H6N7je6eP_VEoLl4-CdRWMOdy0aqJRGSCvrYNs5T-BQlMrsJiexTu1qAlsN8TmsQl3sa8cE0TmarxaLEaBHuGX76i6FUpD4PvsxbwXVGXj1B-caTRqOExjgYuAVpxihPi6_pODRe2XNEPUu63P10QH8EH2W6Io5AdUYySoTqXpIHbYoCEadYYva7oFvDO6ZcOWR_IuUOGrXtyG4HPBSBqRaeZDCY0geE89nk3OyfQrZQtFBuxP6Y-AgRFChaNEVEf20UI1VX8SYMj7BE5fY-F6_oIOsO_PTh5qUkWzy3PmRN-wV1ZFYIW3TaiSczy716VDn06BnlYfWbbuqQjfJDoMxXLwN4YPsnGP_gs9IizfgTafTC4Le8sJowao3XJLYHaeKu0VPy7t-DafrI6f4ZEpFgCwGx9C7lxO8vBzC3EOjfN__MMAeuv79n0mE9LAoYsupJsAijMb_oCy15eEfuMK-xvBn9bAi0mqNkrA8txHf0DXKCMJ1zDCqdnFa2JhkScOhQpX8OX0IzpuEF7PBTZLza4mV6DRtko15ZNeuZenwc6nIuiSvhPaYJaIju743MsnJdTg6DZ_kwevxL7_b9qs" alt="Mermaid Sequence: Burst read file"></a></p><p>The sequence of operations is:</p><ol><li>GCS (client) sends <a href="#OpenFileRO">OpenFileRO</a> command specifying the file path to open. <ul><li>The payload must specify: <code>data[0]</code>= file path string, <code>size</code>=length of file path string.</li></ul></li><li>Drone (server) responds with either <ul><li>ACK on success. The <a href="#payload">payload</a> must specify fields: <code>session</code> = file session id, <code>size</code> = 4, <code>data</code> = length of file that has been opened.</li><li>NAK with <a href="#error_codes">error information</a>, e.g. <code>NoSessionsAvailable</code>, <code>FileExists</code>. The GCS may cancel the operation, depending on the error.</li></ul></li><li>Client (i.e. GCS) sends <a href="#BurstReadFile">BurstReadFile</a> command specifying the part of the file that it wants to get from an offset to the end, along with the default size of each burst payload. <ul><li>The payload must specify: <code>session</code>: the current session id, <code>offset</code> = offset in file of start of burst, <code>size</code>= default length of payload in burst responses, <code>data</code> is ignored.</li></ul></li><li>Server (drone) responds with either <ul><li>ACK on success. The <a href="#payload">payload</a> must specify fields: <code>session</code> = file session id, <code>size</code> = 4, <code>data</code> = length of file in burst.</li><li>NAK with <a href="#error_codes">error information</a>. The client may cancel the operation, depending on the error.</li></ul></li><li>Server sends stream of <a href="#BurstReadFile">BurstReadFile</a> data to client (without ACK) until the whole burst is sent, or a server-defined burst size limit is reached. <ul><li>The payload must specify: <code>session</code>=current session, <code>size</code>=size of data to read per burst message (max equal to payload size = 239), <code>offset</code>= position in original data of current chunk.</li><li>The payload must specify <code>burst_complete=0</code> for all chunks, except the last one, which must set <code>burst_complete=1</code>.</li></ul></li><li>The client must maintain its own record of the received (and missing) chunks. It may request any missing chunks at either the end of a burst or at the end of the file. Missing chunks can be requested using <code>ReadFile</code>.</li><li>Client sends <a href="#TerminateSession">TerminateSession</a> to close the file once all the chunks have been downloaded The server should send an ACK/NAK, but this may (generally speaking) be ignored by the client.</li></ol><p>The client should create a timeout while waiting for a new <code>BurstReadFile</code>, and on expiry may request missing parts of the file using either <code>BurstReadFile</code> or <code>ReadFile</code> A timeout is not set for <code>TerminateSession</code> (the server may ignore failure of the command or the ACK).</p><h3 id="uploading-a-file" tabindex="-1">Uploading a File <a class="header-anchor" href="#uploading-a-file" aria-label="Permalink to &quot;Uploading a File&quot;">​</a></h3><p>The sequence of operations for uploading a file to the drone, assuming there are no timeouts and all operations/requests succeed, is shown below.</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgTm90ZSByaWdodCBvZiBHQ1M6IENyZWF0ZSBmaWxlIG9uIERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBDcmVhdGVGaWxlKCBkYXRhWzBdPXBhdGgsIHNpemU9bGVuKHBhdGgpIClcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSyggc2Vzc2lvbiAsIHNpemU9MCApXG4gICAgTm90ZSByaWdodCBvZiBHQ1M6IFdyaXRlIGRhdGEgaW4gY2h1bmtzPGJyPnVudGlsIGNvbXBsZXRlXG4gICAgR0NTLT4-RHJvbmU6ICBXcml0ZUZpbGUoc2Vzc2lvbiwgc2l6ZT1sZW4oYnVmZmVyKSwgb2Zmc2V0LCBkYXRhPWJ1ZmZlcilcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSyggc2Vzc2lvbiwgc2l6ZT0wIClcbiAgICBOb3RlIHJpZ2h0IG9mIEdDUzogQ2xvc2Ugc2Vzc2lvblxuICAgIEdDUy0-PkRyb25lOiAgVGVybWluYXRlU2Vzc2lvbihzZXNzaW9uKVxuICAgIERyb25lLS0-PkdDUzogQUNLKCkiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgTm90ZSByaWdodCBvZiBHQ1M6IENyZWF0ZSBmaWxlIG9uIERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBDcmVhdGVGaWxlKCBkYXRhWzBdPXBhdGgsIHNpemU9bGVuKHBhdGgpIClcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSyggc2Vzc2lvbiAsIHNpemU9MCApXG4gICAgTm90ZSByaWdodCBvZiBHQ1M6IFdyaXRlIGRhdGEgaW4gY2h1bmtzPGJyPnVudGlsIGNvbXBsZXRlXG4gICAgR0NTLT4-RHJvbmU6ICBXcml0ZUZpbGUoc2Vzc2lvbiwgc2l6ZT1sZW4oYnVmZmVyKSwgb2Zmc2V0LCBkYXRhPWJ1ZmZlcilcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSyggc2Vzc2lvbiwgc2l6ZT0wIClcbiAgICBOb3RlIHJpZ2h0IG9mIEdDUzogQ2xvc2Ugc2Vzc2lvblxuICAgIEdDUy0-PkRyb25lOiAgVGVybWluYXRlU2Vzc2lvbihzZXNzaW9uKVxuICAgIERyb25lLS0-PkdDUzogQUNLKCkiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ" alt="Mermaid Sequence: Uploading a file"></a></p><p>The sequence of operations is:</p><ol><li>GCS (client) sends <a href="#CreateFile">CreateFile</a> command specifying the file path where the file is to be uploaded. <ul><li>The payload must specify: <code>data[0]</code>= target file path string, <code>size</code>=length of file path string.</li></ul></li><li>Drone (server) attempts to create the file, and responds with either <ul><li>ACK on success. The <a href="#payload">payload</a> must specify fields: <code>session</code> = new file session id, <code>size</code> = 0.</li><li>NAK with <a href="#error_codes">error information</a>. <ul><li>The GCS should cancel the whole operation on error.</li><li>If there is a sequence error at this stage the GCS should send a command to <code>ResetSessions</code></li></ul></li></ul></li><li>GCS sends <a href="#WriteFile">WriteFile</a> commands to upload a chunk of data to the Drone. <ul><li>The payload must specify: <code>session</code>=current session id, <code>data</code>=file chunk,<code>size</code>=length of <code>data</code>, <code>offset</code>= offset of data to write</li></ul></li><li>Drone responds to each message with either <ul><li>ACK on success. The <a href="#payload">payload</a> fields are: <code>size</code> = 0.</li><li>NAK on failure with <a href="#error_codes">error information</a>. <ul><li>The GCS should cancel the whole upload operation by sending a command to <code>ResetSessions</code> if there is an NAK.</li></ul></li></ul></li><li>The WriteFile/ACK sequence above is repeated at different offsets to upload the whole file. Once the GCS determines that the upload is complete it moves to the next step.</li><li>GCS sends <a href="#TerminateSession">TerminateSession</a> to close the file. The drone should send an ACK/NAK, but this may (generally speaking) be ignored by the GCS.</li></ol><p>The GSC should create a timeout after <code>CreateFile</code> and <code>WriteFile</code> commands are sent, and resend the messages as needed (and <a href="#timeouts">described above</a>). A timeout is not set for <code>TerminateSession</code> (the server may ignore failure of the command or the ACK).</p><div class="warning custom-block github-alert"><p class="custom-block-title">WARNING</p><p>PX4 and <em>QGroundControl</em> implement this slightly differently than outlined above. The implementation only has a single session (id=0) so only a single operation can be active at a time. As a result, this operation should only be started if no other operation is active. The drone expects that the session id will be set to zero by the sender of <code>CreateFile</code>. Last of all, the GCS sends <code>ResetSessions</code> rather than <code>TerminateSession</code>. While you can send either if talking to PX4, if the protocol is implemented elsewhere calling <code>ResetSessions</code> may break other communications.</p></div><h3 id="remove-file" tabindex="-1">Remove File <a class="header-anchor" href="#remove-file" aria-label="Permalink to &quot;Remove File&quot;">​</a></h3><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><code>RemoveFile</code> handling is implemented in PX4 but not in <em>QGroundControl</em>. GCS behaviour is therefore not fully defined/tested.</p></div><p>The sequence of operations for removing a file is shown below (assuming there are no timeouts and all operations/requests succeed).</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBSZW1vdmVGaWxlKCBkYXRhWzBdPXBhdGgsIHNpemU9bGVuKHBhdGgpIClcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSyhzaXplPTApIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBSZW1vdmVGaWxlKCBkYXRhWzBdPXBhdGgsIHNpemU9bGVuKHBhdGgpIClcbiAgICBEcm9uZS0tPj5HQ1M6IEFDSyhzaXplPTApIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0" alt="Mermaid Sequence: Removing a file"></a></p><p>The sequence of operations is:</p><ol><li>GCS sends <a href="#RemoveFile">RemoveFile</a> command specifying the full path of the file to be deleted. <ul><li>The payload must specify: <code>data[0]</code>= file path string, <code>size</code>=length of file path string.</li></ul></li><li>Drone attempts to delete file, and responds to the message with either: <ul><li>ACK on success, containing payload <code>size</code>=0 (i.e. no data).</li><li>NAK on failure, with <a href="#error_codes">error information</a>.</li><li>The drone must clean up any resources associated with the request after sending the response.</li></ul></li></ol><p>The GSC should create a timeout after the <code>RemoveFile</code> command is sent and resend the message as needed (and <a href="#timeouts">described above</a>).</p><h3 id="truncate-file" tabindex="-1">Truncate File <a class="header-anchor" href="#truncate-file" aria-label="Permalink to &quot;Truncate File&quot;">​</a></h3><p>The sequence of operations for truncating a file is shown below (assuming there are no timeouts and all operations/requests succeed).</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><code>TruncateFile</code> handling is implemented in PX4 but not in <em>QGroundControl</em>. GCS behaviour is therefore not fully defined/tested.</p></div><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBUcnVuY2F0ZUZpbGUgPGJyPiggZGF0YVswXT1wYXRoLCBzaXplPWxlbihwYXRoKSwgb2Zmc2V0PW9mZnNldCB0byB0cnVuY2F0ZSApXG4gICAgRHJvbmUtLT4-R0NTOiBBQ0soc2l6ZT0wKSIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBUcnVuY2F0ZUZpbGUgPGJyPiggZGF0YVswXT1wYXRoLCBzaXplPWxlbihwYXRoKSwgb2Zmc2V0PW9mZnNldCB0byB0cnVuY2F0ZSApXG4gICAgRHJvbmUtLT4-R0NTOiBBQ0soc2l6ZT0wKSIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9" alt="Mermaid Sequence: Truncate file"></a></p><p>The sequence of operations is:</p><ol><li>GCS sends <a href="#TruncateFile">TruncateFile</a> command specifying file to truncate and the offset for truncation. <ul><li>The payload must specify: <code>data[0]</code>= file path string, <code>size</code> = length of file path string, <code>offset</code> = truncation point in file (amount of data to keep).</li></ul></li><li>Drone attempts to truncate file, and responds to the message with either: <ul><li>ACK on success, containing payload <code>size</code>=0 (i.e. no data). <ul><li>The request should succeed if the offset is the same as the file size, and may be attempted if the offset is zero (i.e. truncate whole file).</li></ul></li><li>NAK on failure, with <a href="#error_codes">error information</a>. <ul><li>The request should fail if the offset is 0 (truncate whole file) and for normal file system errors.</li></ul></li><li>The drone must clean up any resources associated with the request after sending the response.</li></ul></li></ol><p>The GSC should create a timeout after the <code>TruncateFile</code> command is sent and resend the message as needed (and <a href="#timeouts">described above</a>).</p><h3 id="list_directory" tabindex="-1">List Directory <a class="header-anchor" href="#list_directory" aria-label="Permalink to &quot;List Directory {#list_directory}&quot;">​</a></h3><p>The sequence of operations for getting a directory listing is shown below (assuming there are no timeouts and all operations/requests succeed).</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgTm90ZSBvdmVyIEdDUyxEcm9uZTogUmVxdWVzdCBlbnRyaWVzIGZyb20gaW5kZXggKG9mZnNldCkgMC48YnI-T25lIG9yIG1vcmUgZW50cmllcyByZXR1cm5lZCBpbiBBQ0suXG4gICAgR0NTLT4-RHJvbmU6IExpc3REaXJlY3RvcnkoIGRhdGFbMF09cGF0aCwgc2l6ZT1sZW4ocGF0aCksIG9mZnNldD0wIClcbiAgICBEcm9uZS0-PkdDUzogQUNLKHNpemUsIGRhdGE9ZW50cmllc19hdF9vZmZzZXRfMClcbiAgICBOb3RlIG92ZXIgR0NTLERyb25lOiBSZXBlYXQgcmVxdWVzdCBpbiBjeWNsZSB0byBnZXQgYWxsPGJyPmVudHJpZXMgKGVhY2ggdGltZSBzZXQgb2Zmc2V0IHRvPGJyPmVudHJ5IGluZGV4IGp1c3QgYWZ0ZXIgbGFzdCBvbmU8YnI-cmVjZWl2ZWQpLlxuICAgIEdDUy0-PkRyb25lOiBMaXN0RGlyZWN0b3J5KCBkYXRhWzBdPXBhdGgsIHNpemU9bGVuKHBhdGgpLCBvZmZzZXQ9Li4uKVxuICAgIERyb25lLT4-R0NTOiBBQ0soc2l6ZSwgZGF0YT1lbnRyaWVzX2F0X29mZnNldClcbiAgICBOb3RlIG92ZXIgR0NTLERyb25lOiBEcm9uZSBOQUNLIHdpdGggRU9GIHdoZW4gYWxsPGJyPmVudHJpZXMgcmV0dXJuZWQ8YnI-KGUuZy4gcmVxdWVzdCB3aXRoOjxicj5vZmZzZXQgPj0gbnVtYmVyIG9mIGVudHJpZXMpLlxuICAgIEdDUy0-PkRyb25lOiAgTGlzdERpcmVjdG9yeSggZGF0YVswXT1wYXRoLCBzaXplPWxlbihwYXRoKSwgb2Zmc2V0PXRvb19iaWcgKVxuICAgIERyb25lLT4-R0NTOiBOQUNLKHNpemU9MSwgZGF0YVswXT1FT0YpIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgTm90ZSBvdmVyIEdDUyxEcm9uZTogUmVxdWVzdCBlbnRyaWVzIGZyb20gaW5kZXggKG9mZnNldCkgMC48YnI-T25lIG9yIG1vcmUgZW50cmllcyByZXR1cm5lZCBpbiBBQ0suXG4gICAgR0NTLT4-RHJvbmU6IExpc3REaXJlY3RvcnkoIGRhdGFbMF09cGF0aCwgc2l6ZT1sZW4ocGF0aCksIG9mZnNldD0wIClcbiAgICBEcm9uZS0-PkdDUzogQUNLKHNpemUsIGRhdGE9ZW50cmllc19hdF9vZmZzZXRfMClcbiAgICBOb3RlIG92ZXIgR0NTLERyb25lOiBSZXBlYXQgcmVxdWVzdCBpbiBjeWNsZSB0byBnZXQgYWxsPGJyPmVudHJpZXMgKGVhY2ggdGltZSBzZXQgb2Zmc2V0IHRvPGJyPmVudHJ5IGluZGV4IGp1c3QgYWZ0ZXIgbGFzdCBvbmU8YnI-cmVjZWl2ZWQpLlxuICAgIEdDUy0-PkRyb25lOiBMaXN0RGlyZWN0b3J5KCBkYXRhWzBdPXBhdGgsIHNpemU9bGVuKHBhdGgpLCBvZmZzZXQ9Li4uKVxuICAgIERyb25lLT4-R0NTOiBBQ0soc2l6ZSwgZGF0YT1lbnRyaWVzX2F0X29mZnNldClcbiAgICBOb3RlIG92ZXIgR0NTLERyb25lOiBEcm9uZSBOQUNLIHdpdGggRU9GIHdoZW4gYWxsPGJyPmVudHJpZXMgcmV0dXJuZWQ8YnI-KGUuZy4gcmVxdWVzdCB3aXRoOjxicj5vZmZzZXQgPj0gbnVtYmVyIG9mIGVudHJpZXMpLlxuICAgIEdDUy0-PkRyb25lOiAgTGlzdERpcmVjdG9yeSggZGF0YVswXT1wYXRoLCBzaXplPWxlbihwYXRoKSwgb2Zmc2V0PXRvb19iaWcgKVxuICAgIERyb25lLT4-R0NTOiBOQUNLKHNpemU9MSwgZGF0YVswXT1FT0YpIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0" alt="Mermaid Sequence: List Directory"></a></p><p>The sequence of operations is:</p><ol><li><p>GCS sends <a href="#ListDirectory">ListDirectory</a> command specifying a directory path and the <strong>index</strong> of an entry.</p><ul><li>The <a href="#payload">payload</a> must specify: <ul><li><code>data[0]</code> = file path</li><li><code>size</code> = length of path string</li><li><code>offset</code> = The index of the first entry to get (0 for first entry, 1 for second, etc.).</li></ul></li></ul></li><li><p>Drone responds with an ACK containing <strong>one or more entries</strong> (the first entry is the one specified in request <code>offset</code> field).</p><ul><li>The payload must specify: <ul><li><code>data[0]</code> = Information for one or more (sequential) entries, starting at the requested entry index (<code>offset</code>). Each entry is separated with a null terminator (<code>\\0</code>), and has the following format (where <code>type</code> is one of the letters <strong>F</strong>(ile), <strong>D</strong>(irectory), <strong>S</strong>(skip))<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;type&gt;&lt;file_or_folder_name&gt;\\t&lt;file_size_in_bytes&gt;\\0</span></span></code></pre></div>For example, given five files named <em>TestFile1.xml</em> to <em>TestFile5.xml</em>, the entries returned at offset 2 might look like: <code>FTestFile3.xml\\t223\\0FTestFile4.xml\\t755568\\0FTestFile5.xml\\t11111\\0</code></li><li><code>size</code> = The size of the <code>data</code>.</li></ul></li></ul></li><li><p>The operation is then repeated at different offsets to download the whole directory listing.</p><div class="note custom-block github-alert"><p class="custom-block-title">&gt; The offset for each request will depend on how many entries were returned by the previous request(s).</p><p></p></div></li><li><p>The operation completes when the GCS requests an entry index (<code>offset</code>) greater than or equal to the number of entries. In this case the drone responds with a <a href="#error_codes">NAK</a> containing <a href="#EOF">EOF</a> (end of file).</p></li></ol><p>The GSC should create a timeout after the <code>ListDirectory</code> command is sent and resend the message as needed (and <a href="#timeouts">described above</a>).</p><p>The drone may also <a href="#error_codes">NAK</a> with an unexpected error. Generally errors are unrecoverable, and the drone must clean up all resources (i.e. close file handles) associated with the request after sending the NAK.</p><h3 id="create-directory" tabindex="-1">Create Directory <a class="header-anchor" href="#create-directory" aria-label="Permalink to &quot;Create Directory&quot;">​</a></h3><p>The sequence of operations for creating a directory is shown below (assuming there are no timeouts and all operations/requests succeed). Note that this operation will fail if the directory is not empty.</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBDcmVhdGVEaXJlY3RvcnkoIGRhdGFbMF09cGF0aCwgc2l6ZT1sZW4ocGF0aCkgKVxuICAgIERyb25lLS0-PkdDUzogQUNLKHNpemU9MCkiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBDcmVhdGVEaXJlY3RvcnkoIGRhdGFbMF09cGF0aCwgc2l6ZT1sZW4ocGF0aCkgKVxuICAgIERyb25lLS0-PkdDUzogQUNLKHNpemU9MCkiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ" alt="Mermaid Sequence: Create Directory"></a></p><p>The sequence of operations is:</p><ol><li>GCS sends <a href="#CreateDirectory">CreateDirectory</a> command specifying the full path of the directory to be created. <ul><li>The payload must specify: <code>data[0]</code>= directory path string, <code>size</code>=length of directory path string.</li></ul></li><li>Drone attempts to create directory, and responds to the message with either: <ul><li>ACK on success, containing payload <code>size</code>=0 (i.e. no data).</li><li>NAK on failure, with <a href="#error_codes">error information</a>.</li><li>The drone must clean up any resources associated with the request after sending the response.</li></ul></li></ol><p>The GSC should not create timeouts or handle the NAK case (other than to report an error to the user).</p><h3 id="remove-directory" tabindex="-1">Remove Directory <a class="header-anchor" href="#remove-directory" aria-label="Permalink to &quot;Remove Directory&quot;">​</a></h3><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><code>RemoveDirectory</code> handling is implemented in PX4 but not in <em>QGroundControl</em>. GCS behaviour is therefore not fully defined/tested.</p></div><p>The sequence of operations for removing a directory is shown below (assuming there are no timeouts and all operations/requests succeed). Note that this operation will fail if the directory is not empty.</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBSZW1vdmVEaXJlY3RvcnkoIGRhdGFbMF09cGF0aCwgc2l6ZT1sZW4ocGF0aCkgKVxuICAgIERyb25lLS0-PkdDUzogQUNLKHNpemU9MCkiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ" target="_blank" rel="noreferrer"><img src="https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtO1xuICAgIHBhcnRpY2lwYW50IEdDU1xuICAgIHBhcnRpY2lwYW50IERyb25lXG4gICAgR0NTLT4-RHJvbmU6ICBSZW1vdmVEaXJlY3RvcnkoIGRhdGFbMF09cGF0aCwgc2l6ZT1sZW4ocGF0aCkgKVxuICAgIERyb25lLS0-PkdDUzogQUNLKHNpemU9MCkiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ" alt="Mermaid Sequence: Remove directory"></a></p><p>The sequence of operations is:</p><ol><li>GCS sends <a href="#RemoveDirectory">RemoveDirectory</a> command specifying the full path of the directory to be deleted. <ul><li>The payload must specify: <code>data[0]</code>= directory path string, <code>size</code>=length of directory path string.</li></ul></li><li>Drone attempts to delete directory, and responds to the message with either: <ul><li>ACK on success, containing payload <code>size</code>=0 (i.e. no data).</li><li>NAK on failure, with <a href="#error_codes">error information</a>.</li><li>The drone must clean up any resources associated with the request after sending the response.</li></ul></li></ol><p>The GSC should create a timeout after the <code>RemoveDirectory</code> command is sent and resend the message as needed (and <a href="#timeouts">described above</a>).</p><h2 id="implementations" tabindex="-1">Implementations <a class="header-anchor" href="#implementations" aria-label="Permalink to &quot;Implementations&quot;">​</a></h2><p>The FTP v1 Protocol has been implemented (at least) in PX4, ArduPilot, QGroundControl and MAVSDK. Those implementations can be used in your own code within the terms of their software licenses.</p><p>PX4 Implementation:</p><ul><li><a href="https://github.com/PX4/Firmware/blob/master/src/modules/mavlink/mavlink_ftp.cpp" target="_blank" rel="noreferrer">src/modules/mavlink/mavlink_ftp.cpp</a></li><li><a href="https://github.com/PX4/Firmware/blob/master/src/modules/mavlink/mavlink_ftp.h" target="_blank" rel="noreferrer">src/modules/mavlink/mavlink_ftp.h</a></li></ul><p><em>QGroundControl</em> implementation:</p><ul><li><a href="https://github.com/mavlink/qgroundcontrol/blob/master/src/Vehicle/FTPManager.cc" target="_blank" rel="noreferrer">src/uas/FileManager.cc</a></li><li><a href="https://github.com/mavlink/qgroundcontrol/blob/master/src/Vehicle/FTPManager.h" target="_blank" rel="noreferrer">/src/uas/FileManager.h</a></li></ul><p>Everything is run by the master (QGC in this case); the slave simply responds to packets in order as they arrive. There’s buffering in the server for a little overlap (two packets in the queue at a time). This is a tradeoff between memory and link latency which may need to be reconsidered at some point.</p><p>The MAVLink receiver thread copies an incoming request verbatim from the MAVLink buffer into a request queue, and queues a low-priority work item to handle the packet. This avoids trying to do file I/O on the MAVLink receiver thread, as well as avoiding yet another worker thread. The worker is responsible for directly queuing replies, which are sent with the same sequence number as the request.</p><p>The implementation on PX4 only supports a single session.</p><h2 id="crc32-implementation" tabindex="-1">CRC32 Implementation <a class="header-anchor" href="#crc32-implementation" aria-label="Permalink to &quot;CRC32 Implementation&quot;">​</a></h2><p>The CRC32 algorithm used by MAVLink FTP is described in <a href="./../guide/crc.html">MAVLink CRCs</a>.</p><h2 id="mavlink-ftp-url-scheme" tabindex="-1">MAVLink FTP URL Scheme <a class="header-anchor" href="#mavlink-ftp-url-scheme" aria-label="Permalink to &quot;MAVLink FTP URL Scheme&quot;">​</a></h2><p>Resources to be downloaded using MAVLink FTP can be referenced using the following URL-like format:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mftp://[;comp=&lt;id&gt;]&lt;path&gt;</span></span></code></pre></div><p>Where:</p><ul><li><code>path</code>: the location of the resource on the target component.</li><li><code>id</code>: target <em>component ID</em> of the component hosting the resource. The <code>[;comp=&lt;id&gt;]</code> part is optional (if omitted, the resource is downloaded from the current component). It should be specified if the request must be redirected</li></ul><p>例如：</p><ul><li>A GCS connected to an autopilot might download a file using the following URL: ## FTP resource &#39;camera.xml&#39; from current component mftp://camera.xml<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>https://mermaid-js.github.io/mermaid-live-editor/edit/#pako:eNqtVE2P0zAQ_Ssjn1Ipu-pKnAKtBIW9ILFSy42iyE0mjYVjB3tCtaz2vzOOk34stKxYemgSz7x58549fhCFLVFkwuP3Dk2B75XcOtm8XhvgXysdqUK10hAstEJDv6-v0P1AF9c_WUKw_DlkpzGYwV2LBiqlEZLKOth0zhM4lKUy28kR1qltTWCrAZ_BMvTFuXYsEJNj-Go-Hwl6hluOL-8SKCXJL9Ovs1ZSnYJXP3Gm0SThcwIDXQRecYmR6u3iYwIevVfWDKhXaV-rRwfyPfqs0CVrAqoxilUmSvWQOGxREow-wwa13QGvGNyx4Moj-Wc5cfCu34aQsudLmJBq5aGQHkPxWHg2nZyz7V2oFpoO3h3JH4FH9gUncmXyvoF_9_GkDJw6qrHqBY3txSd4YrmN72sET4u6M9980KdMwSHPp2j0EHaK6mhSXtim1Ug4m57r9VT-vumn8D_6semqCt0k3R-3YeF_cb0pOucYmfM30vwFzNfX1xdMvuWB1JL3ouGW5PZwankT6Wl7Ny9Td3NQF58sLg_k-ZAYdvb5Ui-PoTT30Cjfn44wKh66_v2kVUj2Iyk3XGoCbMcY_AvLQlses0Er7GoMf1YPw1hYrbEgLM_N3md0jTKScBUrjK5dnCwOilQ0DJWq5Iv7ISSvBV8BDa5Fxq8lVrLTtBZr88ipXcvW4YdSkXUiq6T2mArZkV3dm0Jk5Dock4bLf8h6_AUnGRvv</span></span></code></pre></div></li><li>A GCS connected to an autopilot through a companion computer might host the metadata on the companion (e.g. due to lack of flash space, faster download or if there&#39;s a central MAVFTP server on the vehicle), so it would need to specify the component ID of the component running on the companion (e.g. 100 for the camera), so that the request is redirected: ## FTP resource &#39;/info/version.json&#39; from component with id 100 mftp://[;comp=100]/info/version.json<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>## FTP resource &#39;/info/version.json&#39; from component with id 100</span></span>\n<span class="line"><span>mftp://[;comp=100]/info/version.json</span></span></code></pre></div></li></ul>',115)]))}const g=o(r,[["render",d]]);export{f as __pageData,g as default};
